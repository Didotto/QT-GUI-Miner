package controller;

import javafx.fxml.FXML;
import javafx.stage.WindowEvent;
import javafx.stage.Stage;
import javafx.scene.control.Button;
import javafx.scene.control.TableView;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.input.MouseEvent;
import javafx.scene.control.TableColumn;
import javafx.collections.ObservableList;
import javafx.event.EventHandler;
import javafx.collections.FXCollections;

import javafx.scene.control.TableRow;
import javafx.beans.property.ReadOnlyObjectWrapper;

import model.DataModel;
import view.AlertDialog;
import view.PieChartView;
import view.SaveView;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.IOException;

import java.net.SocketException;
import java.util.LinkedList;
import java.util.List;
import javafx.scene.control.Label;

/**
 * This class manages some events generated by the graphic elements present in the "DataVIsualizzation" view
 */

public class DataVisualizationController extends ColoredController {
	@FXML
	private TableView<List<String>> tableData;
	
	@FXML
	private Button saveButton;
	
	@FXML
	private Button plotButton;
	@FXML
	private Label radiusLabel;
	private ObjectInputStream input;
	private ObjectOutputStream output;
	
	/**
	 * Builds an object instance of DataVisualizationController and initialize the attributes
	 * initializes a row factory such that each row of the table is assigned a color generated by the id of 
	 * the cluster and also adds a handler for the window closing event 
	 * (useful for the proper functioning of the server)
	 * @param model the info of the client
	 * @param controlledStage references to the stage of the window
	 */
	
	public void init(DataModel model, Stage controlledStage) {
		super.init(model, controlledStage);
		input = model.getInputStream();
		output = model.getOutputStream();
		tableData.setRowFactory(tableView -> new TableRow<List<String>>() {
			@Override
			protected void updateItem(List<String> item, boolean empty) {
				super.updateItem(item, empty);
				if(item == null) {
					setGraphic(null);
				}else {
					setStyle("-fx-background-color: #" +
							generatePastelColor(Integer.parseInt(item.get(0))).toString().substring(2, 8));
				}
				
			}
		});
		controlledStage.addEventHandler(WindowEvent.WINDOW_CLOSE_REQUEST, new EventHandler<WindowEvent>(){
            @Override
            public void handle(WindowEvent window)
            {
                closeWindow(window);
            }
        });
	}
	
	/**
	 * Handler for the window closing event (useful for the proper functioning of the server)
	 * @param window the event generated by window closing
	 */
	
	public void closeWindow(WindowEvent window) {
		try {
			output.writeObject(-1);
		}catch (IOException e) {
			new AlertDialog(AlertType.WARNING,
					"WARNING",
					"COMMINICATION ERROR",
					e.getMessage()
					);
		}
	}
	
	/**
	 * Send the name of file to server from which you want to recover the data, receives them,save them in the model,
	 * and shows them in the table
	 * @throws SocketException Thrown to indicate that there is an error creating or accessing a Socket.
	 * @throws IOException Signals that an I/O exception of some sort has occurred.
	 * @throws ClassNotFoundException Thrown when an application tries to load in a class through its string name
	 * @throws ServerException Thrown if there is something wrong with the communication with server
	 */
	
	private void learningFromFile() throws SocketException, IOException, ClassNotFoundException, ServerException{
		output.writeObject(3);
		output.writeObject(model.getFileData().getFileName()+".dmp");
		String result = (String)input.readObject();
		if(result.contentEquals("OK")) {
			model.getFileData().setScheme((LinkedList<String>)input.readObject());
			model.getFileData().setData((LinkedList<LinkedList<String>>)input.readObject());
			model.getFileData().setRadius((Double)input.readObject());
		} else throw new ServerException(result);
		int i=0;
		ObservableList<List<String>> data = FXCollections.observableArrayList(model.getFileData().getData());
		for(String attribute: model.getFileData().getScheme()) {
			final int  j = i;
			TableColumn<List<String>, String> column = new TableColumn<>(attribute);
			column.setCellValueFactory(x -> new ReadOnlyObjectWrapper(x.getValue().get(j)));
			tableData.getColumns().add(column);
			i++;
		}
		tableData.setItems(data);
	}
	
	/**
	 * Send the radius to server, receives the clusters ,save them in the model, and shows them in the table
	 * @throws SocketException Thrown to indicate that there is an error creating or accessing a Socket.
	 * @throws IOException Signals that an I/O exception of some sort has occurred.
	 * @throws ClassNotFoundException Thrown when an application tries to load in a class through its string name
	 * @throws ServerException Thrown if there is something wrong with the communication with server
	 */
	
	private void learningFromDbTable() throws SocketException, IOException, ClassNotFoundException, ServerException{
		output.writeObject(1);
		output.writeObject(model.getDatabaseData().getRadius());
		String result = (String)input.readObject();
		if(result.equals("OK")){
			//recv risultato schema
			model.getDatabaseData().setScheme((LinkedList<String>)input.readObject());
			model.getDatabaseData().setData((LinkedList<LinkedList<LinkedList<String>>>)input.readObject());
			
		} else throw new ServerException(result);
		
		int i=0;
		for(String attribute: model.getDatabaseData().getScheme()) {
			final int  j = i;
			TableColumn<List<String>, String> column = new TableColumn<>(attribute);
			column.setCellValueFactory(x -> new ReadOnlyObjectWrapper(x.getValue().get(j)));
			tableData.getColumns().add(column);
			i++;
		}
		
		ObservableList<List<String>> data = FXCollections.observableArrayList();
		for(List<LinkedList<String>> cluster: model.getDatabaseData().getData()) {
			for(List<String> tuple: cluster) {
				data.add(tuple);
			}
		}
		tableData.setItems(data);
	}
	
	/**
	 * Send the name of tabel stored into db to server
	 * @throws SocketException Thrown to indicate that there is an error creating or accessing a Socket.
	 * @throws IOException Signals that an I/O exception of some sort has occurred.
	 * @throws ClassNotFoundException Thrown when an application tries to load in a class through its string name
	 * @throws ServerException Thrown if there is something wrong with the communication with server
	 */
	
	private void storeTableFromDb() throws SocketException,ServerException,IOException,ClassNotFoundException{
		output.writeObject(0);
		output.writeObject(model.getDatabaseData().getDatabaseTable());
		String result = (String)input.readObject();
		if(!result.equals("OK"))
			throw new ServerException(result);
		
	}
	
	/**
	 * Manages the request for clusters from file or the clustering of the data set from the db
	 * @param isLoadDB true if the data is load from db, false otherwise
	 * @throws SocketException Thrown to indicate that there is an error creating or accessing a Socket.
	 * @throws IOException Signals that an I/O exception of some sort has occurred.
	 * @throws ClassNotFoundException Thrown when an application tries to load in a class through its string name
	 * @throws ServerException Thrown if there is something wrong with the communication with server
	 */
	
	public void updateTable (boolean isLoadDB) throws ServerException, IOException, SocketException, ClassNotFoundException{
		if(!isLoadDB) {
			learningFromFile();
			radiusLabel.setText("Radius : " + model.getFileData().getRadius());
		}else {
			storeTableFromDb();
			learningFromDbTable();
		}
	}
	
	/**
	 * Handler for the event generated by the click of the "Save" button (save the clusters in file)
	 * @param e the event generated by Save click 
	 */
	
	public void saveClicked (MouseEvent e) {
		try {
			new SaveView(this.model);
		}catch (IOException ex){
			new AlertDialog(AlertType.WARNING,
					"ERROR",
					"ERROR OPENING A NEW WINDOW",
					"Unable to open a new saving window. Try again...!"
					);
		}
	}
	

	/**
	 * Handler for the event generated by the click of the "Plot" button (create a piechart)
	 * @param e the event generated by Plot click 
	 */
	
	 public void plotClicked (MouseEvent e){
		 try {
			 new PieChartView(this.model);
		 } catch (IOException ex) {
			 new AlertDialog(AlertType.WARNING,
						"ERROR",
						"ERROR OPENING A NEW WINDOW",
						"Unable to open a new chart window. Try again...!"
						);
		 }
	 }
	 
}
